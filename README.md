API is the acronym for application programming interface, a software intermediary that allows two applications to talk to each other. APIs are an accessible way to extract and share data within and across organizations.

web programming languages have features to ease the mundane processes of creating an API, as well as frameworks that make that job even easier.

In this repository we will use Laravel 8, a PHP framework.

We are going to create a application that manages products in stock:

Create product;
Update product;
Delete product;


For this we gonna following these steps:

Creation Product Model;

Creation Product Controller;

creation of Routes;

Tests;

Let's get to work at! :star_struck:


Laravel cames with a command-line interface called Artisan, witch makes easy to creates the project structure. Let's use it to create our Model, Migration and Controller.

<h2>1° Step</h2>

<h3>Criando Model, Migration and Controller by Artisan</h3>

```php
php arisan make:model Product -mc --api
```

The above command has create three file for us:

Product Model File
app/Models/
Product.php

This is the file that create a object to relate with the database table Product, that one we are going at the next step.

Product Migration File
/database/migrations
[current datatime]_create_products_table.php

This file is going to create a object map of Product Table.
In this file we are going to work soon, to genarate the table Product on are database.

Product Controller File
/app/Http/ProductController
Here is where we are going to fill with the actions for each route

Great! Until now we just have to execute one command-line and it has done a big percent of our work.


<h2>2° Step</h2>

<h3>Creating the routes</h3>

Open the file routes/api.php. 
Here i where we are going to create the routes to access the Controller Methods.

For routes:

GET /api/index = it will acess the ProductController index()
POST /api/store = it will access the ProductController store()
GET /api/show/{id} = it will access the ProductController show(Product id)
PUT /api/update/{id} = it will acess the ProductController update(Product id)
DELETE /api/destroy/{id} = it will acess the ProductController destroy(Product id)

Since we are creating inside the api.php, it understand that our route has the 'api/' prefixed to the method on our route, so we don't need to add it, just the name after "api/".

Creating the routs on api.php:


Product.index =  Display a listing of the resource.
```php

Route::get('index', [ProductController::class, 'index']);
```

Product.store =  Store a newly created resource in storage.
```php
Route::post('store', [ProductController::class, 'store']);
```

Product.show = Display the specified resource.
```php
Route::post('show/{id}', [ProductController::class, 'show']);
```

Product.update = update the specified resouce in storage.
```php
Route::post('store/{id}', [ProductController::class, 'store']);
```

It's done! We just created every route we need to access our resources.

Laravel has another easer and practical way to route the CRUD Controller Methods.
Instead one route to each method, you can use the Laravel Method Route::resource, like that way:

```php
Route::resource('product',ProductController::class);
```

This understand the routes using HTTP Request Method sincronyzed with Controller methods names generated by Artisan.
Feel free to choice the method you prefer to use in your api route file.


<h2>3° Step</h2>

<h3> Database Configuration </h3>


Let's onfigurate the database access information. Open the file '.env' on the root of your project and in the database config, feed it with your database base infos.
Example:

```php
DB_CONNECTION=mysql
DB_HOST=localhost
DB_PORT=3306
DB_DATABASE=store
DB_USERNAME=username
DB_PASSWORD=password
```

- Updating migration file.

Open the database/migrations/DATATIME_create_products_table.php (the name is going to start with the database that it was created).

Change the method 'UP' to this:

    public function up()
    {
        Schema::create('products', function (Blueprint $table) {
            $table->id();
            $table->string('name');
            $table->integer('quantity');
            $table->timestamps();
        });
    }


Here we are creating the structure of Products table. We just add to lines to up() method. These lines means name and quantity collumns we are add to Products table. 


Now let's run our database datas. Remember that in the first step we have generated a migration file by artisan command-line when we created the ProductController? This file create a database table structure of our Product table. And now, we are going to ask artisan to create a table structure with the informations on this file.

```php
php artisan migrate
```
That command is going to run every file inside the database/migration directory that has no been ran before. It is manager by cache and migration_file_name datatime. 


<h4>Fillable field</h4>

Laravel Model has a property called "$fillable", it is a array property where you inform each field that can be mass assigned. As a secure method just the table fields list in this property can be used by store and update method.

Considering that, let's open the product model generated by artisan on the 1° step
into app/model/Products.php. Then add the atributte to Product class:

```php
    protected $fillable = ['name', 'quantity'];
```

<4>Seeding Product table</4>

For the purpose of facilitating our tests, we are feed de product table with fake datas. And Laravel as a automatica way to do that.


```php
php artisan make:seeder ProductSeeder
```

Open the file that artisan has generated in database/seeders/ProductSeeder.php
and add this code to run() method:

```php
        //truncate the Product table
        Product::truncate();

        //A class that generate a lot of kinds of fake datas
        $faker = \Faker\Factory::create();

        //create 10 fake registers
        for ($i = 0; $i < 10; $i++) {
            Product::create([
                'name' => $faker->sentence,
                'quantity' => rand(0,1000), //rand number between 0 to 1000
            ]);
        }
```

Now we need to call the ProductSeeder class in DatabaseSeeder to execute our class.
Open database/seeders/DatabaseSeeder.php and replace the method run() withe the follow code:

```php
    public function run()
    {
        $this->call([ProductSeeder::class,]);
    }
```

Great! Let's feed our product table by artisan:
```php
     php artisan db:seed
```

It's that! We already have our database fed and ready to manage Product datas.



<h2>4° Step</h2>

<h3> Insert action into ProductController </h3>

- Open the file /app/Httpd/Controller/ProductController.php. The one which has been generated by artisan command-line.


<h4>ProductController@index</h4>


Let's start with method Index. That method has to display a list of all Products from database.

add this code into the method index():

```php
public function index(){
   return Product::all();    
}
```

The code above is enough to return a list of Product from the database.


<h4>ProductController@store</h4>

```php 
public function store(Request $request){
    return Product::create($request->post());
}
```
<h4>ProductController@show</h4>

```php 
    public function show(Product $product)
    {
        return $product;
    }
```

That is a beautifull evolution about Laravel and PHP where we pass the Product ID by GET and the Product parameter makes the magic to populate itself with that Id data.

<h4>ProductController@show</h4>

```php 
    public function show(Product $product)
    {
        return $product;
    }
```

<h4>ProductController@update</h4>

```php
    public function update(Request $request, Product $product)
    {
        return $product->update($request->all());
    }
```

<h4>ProductController@destroy</h4>

```php
    public function update(Product $product)
    {
        return $product->delete();
    }
```

That is it :smiling:

We just finish a basic crud API aplication. Easy? Maybe! I do think that until get started coding is a little painful. Too much configurations, and steps that is no about coding. But after you start to code that get realy easy and intuitive.

So I think the best part become after that, when you really start coding.

We are going to let it more mature with validation, token acess, indepentent resource and request files, and more. And we going to have one repository for each tutorial, to get a historic about each step.

That is it. Thanks :smiling:

